# Quick-Start-Ils

**Source URL:** https://docs.videosdk.live/react-native/guide/video-and-audio-calling-api-sdk/quick-start-ILS

VideoSDK empowers you to seamlessly integrate the Http Live Streaming(HLS) feature into your React Native application within minutes.

In this quickstart, you'll explore this feature of VideoSDK. Follow the step-by-step guide to integrate it within your application.

For low-latency interactive live streaming (under 100ms), follow this documentation.

### Prerequisites​

Before proceeding, ensure that your development environment meets the following requirements:

- Video SDK Developer Account (Not having one, follow Video SDK Dashboard)
- Basic understanding of React Native
- Node.js v12+
- NPM v6+ (comes installed with newer Node versions)
- Android Studio or Xcode installed

One should have a VideoSDK account to generate token.
Visit VideoSDK dashboard to generate token

### App Architecture​

The App will contain the following screens:

1. Join Screen : This screen allows the SPEAKER to create a studio or join a predefined studio, and SIGNALLING_ONLY to join a predefined studio.
1. Speaker Screen : This screen contains the list of speakers and studio controls, such as enabling/disabling the microphone and camera, and leaving the studio.
1. Viewer Screen : This screen includes a live stream player where viewers can watch the stream.

Join Screen : This screen allows the SPEAKER to create a studio or join a predefined studio, and SIGNALLING_ONLY to join a predefined studio.

`Join Screen`
Speaker Screen : This screen contains the list of speakers and studio controls, such as enabling/disabling the microphone and camera, and leaving the studio.

`Speaker Screen`
Viewer Screen : This screen includes a live stream player where viewers can watch the stream.

`Viewer Screen`
## Getting Started with the Code!​

### Create App​

Create a new React Native App using the below command.

```
npx react-native init AppName
```

`npx react-native init AppName`
For React Native setup, you can follow the Official Documentation.

### VideoSDK Installation​

Install the VideoSDK by using the following command. Ensure that you are in your project directory before running this command.

- NPMYarn

```
npm install "@videosdk.live/react-native-sdk"  "@videosdk.live/react-native-incallmanager"
```

`npm install "@videosdk.live/react-native-sdk"  "@videosdk.live/react-native-incallmanager"`
```
yarn add "@videosdk.live/react-native-sdk"  "@videosdk.live/react-native-incallmanager"
```

`yarn add "@videosdk.live/react-native-sdk"  "@videosdk.live/react-native-incallmanager"`
### Project Structure​

```
  root   ├── node_modules   ├── android   ├── ios   ├── App.js   ├── api.js   ├── index.js
```

`  root   ├── node_modules   ├── android   ├── ios   ├── App.js   ├── api.js   ├── index.js`
### Project Configuration​

#### Android Setup​

```
<manifest  xmlns:android="http://schemas.android.com/apk/res/android"  package="com.cool.app">    <!-- Give all the required permissions to app -->    <uses-permission android:name="android.permission.INTERNET" />    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />    <!-- Needed to communicate with already-paired Bluetooth devices. (Legacy up to Android 11) -->    <uses-permission        android:name="android.permission.BLUETOOTH"        android:maxSdkVersion="30" />    <uses-permission        android:name="android.permission.BLUETOOTH_ADMIN"        android:maxSdkVersion="30" />    <!-- Needed to communicate with already-paired Bluetooth devices. (Android 12 upwards)-->    <uses-permission android:name="android.permission.BLUETOOTH_CONNECT" />    <uses-permission android:name="android.permission.CAMERA" />    <uses-permission android:name="android.permission.MODIFY_AUDIO_SETTINGS" />    <uses-permission android:name="android.permission.RECORD_AUDIO" />    <uses-permission android:name="android.permission.WAKE_LOCK" /></manifest>
```

`<manifest  xmlns:android="http://schemas.android.com/apk/res/android"  package="com.cool.app">    <!-- Give all the required permissions to app -->    <uses-permission android:name="android.permission.INTERNET" />    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />    <!-- Needed to communicate with already-paired Bluetooth devices. (Legacy up to Android 11) -->    <uses-permission        android:name="android.permission.BLUETOOTH"        android:maxSdkVersion="30" />    <uses-permission        android:name="android.permission.BLUETOOTH_ADMIN"        android:maxSdkVersion="30" />    <!-- Needed to communicate with already-paired Bluetooth devices. (Android 12 upwards)-->    <uses-permission android:name="android.permission.BLUETOOTH_CONNECT" />    <uses-permission android:name="android.permission.CAMERA" />    <uses-permission android:name="android.permission.MODIFY_AUDIO_SETTINGS" />    <uses-permission android:name="android.permission.RECORD_AUDIO" />    <uses-permission android:name="android.permission.WAKE_LOCK" /></manifest>`
```
  dependencies {   implementation project(':rnwebrtc')  }
```

`  dependencies {   implementation project(':rnwebrtc')  }`
```
include ':rnwebrtc'project(':rnwebrtc').projectDir = new File(rootProject.projectDir, '../node_modules/@videosdk.live/react-native-webrtc/android')
```

`include ':rnwebrtc'project(':rnwebrtc').projectDir = new File(rootProject.projectDir, '../node_modules/@videosdk.live/react-native-webrtc/android')`
```
import live.videosdk.rnwebrtc.WebRTCModulePackage;public class MainApplication extends Application implements ReactApplication {  private static List<ReactPackage> getPackages() {      @SuppressWarnings("UnnecessaryLocalVariable")      List<ReactPackage> packages = new PackageList(this).getPackages();      // Packages that cannot be autolinked yet can be added manually here, for example:      packages.add(new WebRTCModulePackage());      return packages;  }}
```

`import live.videosdk.rnwebrtc.WebRTCModulePackage;public class MainApplication extends Application implements ReactApplication {  private static List<ReactPackage> getPackages() {      @SuppressWarnings("UnnecessaryLocalVariable")      List<ReactPackage> packages = new PackageList(this).getPackages();      // Packages that cannot be autolinked yet can be added manually here, for example:      packages.add(new WebRTCModulePackage());      return packages;  }}`
```
/* This one fixes a weird WebRTC runtime problem on some devices. */android.enableDexingArtifactTransform.desugaring=false
```

`/* This one fixes a weird WebRTC runtime problem on some devices. */android.enableDexingArtifactTransform.desugaring=false`
```
-keep class org.webrtc.** { *; }
```

`-keep class org.webrtc.** { *; }`
```
buildscript {  ext {      minSdkVersion = 23  }}
```

`buildscript {  ext {      minSdkVersion = 23  }}`
#### iOS Setup​

To update CocoaPods, you can reinstall the gem using the following command:$ sudo gem install cocoapods

```
$ sudo gem install cocoapods
```

`$ sudo gem install cocoapods`
Select Your_Xcode_Project/TARGETS/BuildSettings, in Header Search Paths, add "$(SRCROOT)/../node_modules/@videosdk.live/react-native-incall-manager/ios/RNInCallManager"

`Your_Xcode_Project/TARGETS/BuildSettings`
`"$(SRCROOT)/../node_modules/@videosdk.live/react-native-incall-manager/ios/RNInCallManager"`
```
pod ‘react-native-webrtc’, :path => ‘../node_modules/@videosdk.live/react-native-webrtc’
```

`pod ‘react-native-webrtc’, :path => ‘../node_modules/@videosdk.live/react-native-webrtc’`
You need to change the platform field in the Podfile to 12.0 or above because react-native-webrtc doesn't support iOS versions earlier than 12.0. Update the line: platform : ios, ‘12.0’.

After updating the version, you need to install the pods by running the following command:Pod install

```
Pod install
```

`Pod install`
Add the following lines to your info.plist file located at (project folder/ios/projectname/info.plist):ios/projectname/info.plist<key>NSCameraUsageDescription</key><string>Camera permission description</string><key>NSMicrophoneUsageDescription</key><string>Microphone permission description</string>

```
<key>NSCameraUsageDescription</key><string>Camera permission description</string><key>NSMicrophoneUsageDescription</key><string>Microphone permission description</string>
```

`<key>NSCameraUsageDescription</key><string>Camera permission description</string><key>NSMicrophoneUsageDescription</key><string>Microphone permission description</string>`
#### Register Service​

Register VideoSDK services in your root index.js file for the initialization service.

`index.js`
```
import { AppRegistry } from "react-native";import App from "./App";import { name as appName } from "./app.json";import { register } from "@videosdk.live/react-native-sdk";register();AppRegistry.registerComponent(appName, () => App);
```

`import { AppRegistry } from "react-native";import App from "./App";import { name as appName } from "./app.json";import { register } from "@videosdk.live/react-native-sdk";register();AppRegistry.registerComponent(appName, () => App);`
### Step 1: Get started with API.js​

Prior to moving on, you must create an API request to generate a unique streamId. You will need an authentication token, which you can create either through the videosdk-rtc-api-server-examples or directly from the VideoSDK Dashboard for developers.api.js//Auth token we will use to generate a streamId and connect to itexport const authToken = "<Generated-from-dashboard>";// API call to create streamexport const createStream = async ({ token }) => {  const res = await fetch(`https://api.videosdk.live/v2/rooms`, {    method: "POST",    headers: {      authorization: `${token}`,      "Content-Type": "application/json",    },    body: JSON.stringify({}),  });  //Destructuring the streamId from the response  const { roomId: streamId } = await res.json();  return streamId;};

```
//Auth token we will use to generate a streamId and connect to itexport const authToken = "<Generated-from-dashboard>";// API call to create streamexport const createStream = async ({ token }) => {  const res = await fetch(`https://api.videosdk.live/v2/rooms`, {    method: "POST",    headers: {      authorization: `${token}`,      "Content-Type": "application/json",    },    body: JSON.stringify({}),  });  //Destructuring the streamId from the response  const { roomId: streamId } = await res.json();  return streamId;};
```

`//Auth token we will use to generate a streamId and connect to itexport const authToken = "<Generated-from-dashboard>";// API call to create streamexport const createStream = async ({ token }) => {  const res = await fetch(`https://api.videosdk.live/v2/rooms`, {    method: "POST",    headers: {      authorization: `${token}`,      "Content-Type": "application/json",    },    body: JSON.stringify({}),  });  //Destructuring the streamId from the response  const { roomId: streamId } = await res.json();  return streamId;};`
### Step 2: Wireframe App.js with all the components​

To build up wireframe of App.js, you need to use VideoSDK Hooks and Context Providers. VideoSDK provides MeetingProvider, MeetingConsumer, useMeeting and useParticipant hooks.First you need to understand Context Provider and Consumer. Context is primarily used when some data needs to be accessible by many components at different nesting levels.
MeetingProvider: This is the Context Provider. It accepts value config and token as props. The Provider component accepts a value prop to be passed to consuming components that are descendants of this Provider. One Provider can be connected to many consumers. Providers can be nested to override values deeper within the tree.
MeetingConsumer: This is the Context Consumer. All consumers that are descendants of a Provider will re-render whenever the Provider’s value prop changes.
useMeeting: This is the meeting hook API. It includes all the information related to meeting such as join, leave, enable/disable mic or webcam etc.
useParticipant: This is the participant hook API. It is responsible for handling all the events and props related to one particular participant such as name, webcamStream, micStream etc.
The Meeting Context provides a way to listen for any changes that occur when a participant joins the meeting or makes modifications to their microphone, camera, and other settings.Begin by making a few changes to the code in the App.js file.App.jsimport React, { useState, useMemo, useRef, useEffect } from "react";import {  SafeAreaView,  TouchableOpacity,  Text,  TextInput,  View,  FlatList,  Clipboard,} from "react-native";import {  MeetingProvider,  useMeeting,  useParticipant,  MediaStream,  RTCView,  Constants,} from "@videosdk.live/react-native-sdk";import { createMeeting, authToken } from "./api";// Responsible for either scheduling a new meeting or joining an existing one as a host or as a viewer.function JoinScreen({ getMeetingAndToken, setMode }) {  return null;}// Responsible for managing participant video streamfunction ParticipantView(props) {  return null;}// Responsible for managing meeting controls such as toggle mic / webcam and leavefunction Controls() {  return null;}// Responsible for Speaker side view, which contains Meeting Controls(toggle mic/webcam & leave) and Participant listfunction SpeakerView() {  return null;}// Responsible for Viewer side view, which contains video player for streaming HLS and managing HLS state (HLS_STARTED, HLS_STOPPING, HLS_STARTING, etc.)function ViewerView() {  return null;}// Responsible for managing two views (Speaker & Viewer) based on provided mode (`SEND_AND_RECV` & `SIGNALLING_ONLY`)function Container(props) {  return null;}function App() {  const [meetingId, setMeetingId] = useState(null);  //State to handle the mode of the participant i.e. SEND_AND_RECV or SIGNALLING_ONLY  const [mode, setMode] = useState("SEND_AND_RECV");  //Getting MeetingId from the API created earlier  const getMeetingAndToken = async (id) => {    const meetingId =      id == null ? await createMeeting({ token: authToken }) : id;    setMeetingId(meetingId);  };  return authToken && meetingId ? (    <MeetingProvider      config={{        meetingId,        micEnabled: true,        webcamEnabled: true,        name: "C.V. Raman",        //This will be the mode of the participant SEND_AND_RECV or SIGNALLING_ONLY        mode: mode,      }}      token={authToken}    >      <Container />    </MeetingProvider>  ) : (    <JoinScreen getMeetingAndToken={getMeetingAndToken} setMode={setMode} />  );}export default App;

First you need to understand Context Provider and Consumer. Context is primarily used when some data needs to be accessible by many components at different nesting levels.
MeetingProvider: This is the Context Provider. It accepts value config and token as props. The Provider component accepts a value prop to be passed to consuming components that are descendants of this Provider. One Provider can be connected to many consumers. Providers can be nested to override values deeper within the tree.
MeetingConsumer: This is the Context Consumer. All consumers that are descendants of a Provider will re-render whenever the Provider’s value prop changes.
useMeeting: This is the meeting hook API. It includes all the information related to meeting such as join, leave, enable/disable mic or webcam etc.
useParticipant: This is the participant hook API. It is responsible for handling all the events and props related to one particular participant such as name, webcamStream, micStream etc.
The Meeting Context provides a way to listen for any changes that occur when a participant joins the meeting or makes modifications to their microphone, camera, and other settings.Begin by making a few changes to the code in the App.js file.App.jsimport React, { useState, useMemo, useRef, useEffect } from "react";import {  SafeAreaView,  TouchableOpacity,  Text,  TextInput,  View,  FlatList,  Clipboard,} from "react-native";import {  MeetingProvider,  useMeeting,  useParticipant,  MediaStream,  RTCView,  Constants,} from "@videosdk.live/react-native-sdk";import { createMeeting, authToken } from "./api";// Responsible for either scheduling a new meeting or joining an existing one as a host or as a viewer.function JoinScreen({ getMeetingAndToken, setMode }) {  return null;}// Responsible for managing participant video streamfunction ParticipantView(props) {  return null;}// Responsible for managing meeting controls such as toggle mic / webcam and leavefunction Controls() {  return null;}// Responsible for Speaker side view, which contains Meeting Controls(toggle mic/webcam & leave) and Participant listfunction SpeakerView() {  return null;}// Responsible for Viewer side view, which contains video player for streaming HLS and managing HLS state (HLS_STARTED, HLS_STOPPING, HLS_STARTING, etc.)function ViewerView() {  return null;}// Responsible for managing two views (Speaker & Viewer) based on provided mode (`SEND_AND_RECV` & `SIGNALLING_ONLY`)function Container(props) {  return null;}function App() {  const [meetingId, setMeetingId] = useState(null);  //State to handle the mode of the participant i.e. SEND_AND_RECV or SIGNALLING_ONLY  const [mode, setMode] = useState("SEND_AND_RECV");  //Getting MeetingId from the API created earlier  const getMeetingAndToken = async (id) => {    const meetingId =      id == null ? await createMeeting({ token: authToken }) : id;    setMeetingId(meetingId);  };  return authToken && meetingId ? (    <MeetingProvider      config={{        meetingId,        micEnabled: true,        webcamEnabled: true,        name: "C.V. Raman",        //This will be the mode of the participant SEND_AND_RECV or SIGNALLING_ONLY        mode: mode,      }}      token={authToken}    >      <Container />    </MeetingProvider>  ) : (    <JoinScreen getMeetingAndToken={getMeetingAndToken} setMode={setMode} />  );}export default App;

- MeetingProvider: This is the Context Provider. It accepts value config and token as props. The Provider component accepts a value prop to be passed to consuming components that are descendants of this Provider. One Provider can be connected to many consumers. Providers can be nested to override values deeper within the tree.
- MeetingConsumer: This is the Context Consumer. All consumers that are descendants of a Provider will re-render whenever the Provider’s value prop changes.
- useMeeting: This is the meeting hook API. It includes all the information related to meeting such as join, leave, enable/disable mic or webcam etc.
- useParticipant: This is the participant hook API. It is responsible for handling all the events and props related to one particular participant such as name, webcamStream, micStream etc.

`config`
`token`
The Meeting Context provides a way to listen for any changes that occur when a participant joins the meeting or makes modifications to their microphone, camera, and other settings.Begin by making a few changes to the code in the App.js file.App.jsimport React, { useState, useMemo, useRef, useEffect } from "react";import {  SafeAreaView,  TouchableOpacity,  Text,  TextInput,  View,  FlatList,  Clipboard,} from "react-native";import {  MeetingProvider,  useMeeting,  useParticipant,  MediaStream,  RTCView,  Constants,} from "@videosdk.live/react-native-sdk";import { createMeeting, authToken } from "./api";// Responsible for either scheduling a new meeting or joining an existing one as a host or as a viewer.function JoinScreen({ getMeetingAndToken, setMode }) {  return null;}// Responsible for managing participant video streamfunction ParticipantView(props) {  return null;}// Responsible for managing meeting controls such as toggle mic / webcam and leavefunction Controls() {  return null;}// Responsible for Speaker side view, which contains Meeting Controls(toggle mic/webcam & leave) and Participant listfunction SpeakerView() {  return null;}// Responsible for Viewer side view, which contains video player for streaming HLS and managing HLS state (HLS_STARTED, HLS_STOPPING, HLS_STARTING, etc.)function ViewerView() {  return null;}// Responsible for managing two views (Speaker & Viewer) based on provided mode (`SEND_AND_RECV` & `SIGNALLING_ONLY`)function Container(props) {  return null;}function App() {  const [meetingId, setMeetingId] = useState(null);  //State to handle the mode of the participant i.e. SEND_AND_RECV or SIGNALLING_ONLY  const [mode, setMode] = useState("SEND_AND_RECV");  //Getting MeetingId from the API created earlier  const getMeetingAndToken = async (id) => {    const meetingId =      id == null ? await createMeeting({ token: authToken }) : id;    setMeetingId(meetingId);  };  return authToken && meetingId ? (    <MeetingProvider      config={{        meetingId,        micEnabled: true,        webcamEnabled: true,        name: "C.V. Raman",        //This will be the mode of the participant SEND_AND_RECV or SIGNALLING_ONLY        mode: mode,      }}      token={authToken}    >      <Container />    </MeetingProvider>  ) : (    <JoinScreen getMeetingAndToken={getMeetingAndToken} setMode={setMode} />  );}export default App;

Begin by making a few changes to the code in the App.js file.App.jsimport React, { useState, useMemo, useRef, useEffect } from "react";import {  SafeAreaView,  TouchableOpacity,  Text,  TextInput,  View,  FlatList,  Clipboard,} from "react-native";import {  MeetingProvider,  useMeeting,  useParticipant,  MediaStream,  RTCView,  Constants,} from "@videosdk.live/react-native-sdk";import { createMeeting, authToken } from "./api";// Responsible for either scheduling a new meeting or joining an existing one as a host or as a viewer.function JoinScreen({ getMeetingAndToken, setMode }) {  return null;}// Responsible for managing participant video streamfunction ParticipantView(props) {  return null;}// Responsible for managing meeting controls such as toggle mic / webcam and leavefunction Controls() {  return null;}// Responsible for Speaker side view, which contains Meeting Controls(toggle mic/webcam & leave) and Participant listfunction SpeakerView() {  return null;}// Responsible for Viewer side view, which contains video player for streaming HLS and managing HLS state (HLS_STARTED, HLS_STOPPING, HLS_STARTING, etc.)function ViewerView() {  return null;}// Responsible for managing two views (Speaker & Viewer) based on provided mode (`SEND_AND_RECV` & `SIGNALLING_ONLY`)function Container(props) {  return null;}function App() {  const [meetingId, setMeetingId] = useState(null);  //State to handle the mode of the participant i.e. SEND_AND_RECV or SIGNALLING_ONLY  const [mode, setMode] = useState("SEND_AND_RECV");  //Getting MeetingId from the API created earlier  const getMeetingAndToken = async (id) => {    const meetingId =      id == null ? await createMeeting({ token: authToken }) : id;    setMeetingId(meetingId);  };  return authToken && meetingId ? (    <MeetingProvider      config={{        meetingId,        micEnabled: true,        webcamEnabled: true,        name: "C.V. Raman",        //This will be the mode of the participant SEND_AND_RECV or SIGNALLING_ONLY        mode: mode,      }}      token={authToken}    >      <Container />    </MeetingProvider>  ) : (    <JoinScreen getMeetingAndToken={getMeetingAndToken} setMode={setMode} />  );}export default App;

```
import React, { useState, useMemo, useRef, useEffect } from "react";import {  SafeAreaView,  TouchableOpacity,  Text,  TextInput,  View,  FlatList,  Clipboard,} from "react-native";import {  MeetingProvider,  useMeeting,  useParticipant,  MediaStream,  RTCView,  Constants,} from "@videosdk.live/react-native-sdk";import { createMeeting, authToken } from "./api";// Responsible for either scheduling a new meeting or joining an existing one as a host or as a viewer.function JoinScreen({ getMeetingAndToken, setMode }) {  return null;}// Responsible for managing participant video streamfunction ParticipantView(props) {  return null;}// Responsible for managing meeting controls such as toggle mic / webcam and leavefunction Controls() {  return null;}// Responsible for Speaker side view, which contains Meeting Controls(toggle mic/webcam & leave) and Participant listfunction SpeakerView() {  return null;}// Responsible for Viewer side view, which contains video player for streaming HLS and managing HLS state (HLS_STARTED, HLS_STOPPING, HLS_STARTING, etc.)function ViewerView() {  return null;}// Responsible for managing two views (Speaker & Viewer) based on provided mode (`SEND_AND_RECV` & `SIGNALLING_ONLY`)function Container(props) {  return null;}function App() {  const [meetingId, setMeetingId] = useState(null);  //State to handle the mode of the participant i.e. SEND_AND_RECV or SIGNALLING_ONLY  const [mode, setMode] = useState("SEND_AND_RECV");  //Getting MeetingId from the API created earlier  const getMeetingAndToken = async (id) => {    const meetingId =      id == null ? await createMeeting({ token: authToken }) : id;    setMeetingId(meetingId);  };  return authToken && meetingId ? (    <MeetingProvider      config={{        meetingId,        micEnabled: true,        webcamEnabled: true,        name: "C.V. Raman",        //This will be the mode of the participant SEND_AND_RECV or SIGNALLING_ONLY        mode: mode,      }}      token={authToken}    >      <Container />    </MeetingProvider>  ) : (    <JoinScreen getMeetingAndToken={getMeetingAndToken} setMode={setMode} />  );}export default App;
```

`import React, { useState, useMemo, useRef, useEffect } from "react";import {  SafeAreaView,  TouchableOpacity,  Text,  TextInput,  View,  FlatList,  Clipboard,} from "react-native";import {  MeetingProvider,  useMeeting,  useParticipant,  MediaStream,  RTCView,  Constants,} from "@videosdk.live/react-native-sdk";import { createMeeting, authToken } from "./api";// Responsible for either scheduling a new meeting or joining an existing one as a host or as a viewer.function JoinScreen({ getMeetingAndToken, setMode }) {  return null;}// Responsible for managing participant video streamfunction ParticipantView(props) {  return null;}// Responsible for managing meeting controls such as toggle mic / webcam and leavefunction Controls() {  return null;}// Responsible for Speaker side view, which contains Meeting Controls(toggle mic/webcam & leave) and Participant listfunction SpeakerView() {  return null;}// Responsible for Viewer side view, which contains video player for streaming HLS and managing HLS state (HLS_STARTED, HLS_STOPPING, HLS_STARTING, etc.)function ViewerView() {  return null;}// Responsible for managing two views (Speaker & Viewer) based on provided mode (`SEND_AND_RECV` & `SIGNALLING_ONLY`)function Container(props) {  return null;}function App() {  const [meetingId, setMeetingId] = useState(null);  //State to handle the mode of the participant i.e. SEND_AND_RECV or SIGNALLING_ONLY  const [mode, setMode] = useState("SEND_AND_RECV");  //Getting MeetingId from the API created earlier  const getMeetingAndToken = async (id) => {    const meetingId =      id == null ? await createMeeting({ token: authToken }) : id;    setMeetingId(meetingId);  };  return authToken && meetingId ? (    <MeetingProvider      config={{        meetingId,        micEnabled: true,        webcamEnabled: true,        name: "C.V. Raman",        //This will be the mode of the participant SEND_AND_RECV or SIGNALLING_ONLY        mode: mode,      }}      token={authToken}    >      <Container />    </MeetingProvider>  ) : (    <JoinScreen getMeetingAndToken={getMeetingAndToken} setMode={setMode} />  );}export default App;`
### Step 3: Implement Join Screen​

Join screen will work as medium to either schedule a new meeting or to join an existing one as a host or as a viewer.This functionality will have 3 buttons:1. Join as Host: When this button is clicked, the person will join the meeting with the entered meetingId as HOST.2. Join as Viewer: When this button is clicked, the person will join the meeting with the entered meetingId as SIGNALLING_ONLY.3. Create Studio Room: When this button is clicked, the person will join a new meeting as HOST.JoinScreen Componentfunction JoinScreen({ getMeetingAndToken, setMode }) {  const [meetingVal, setMeetingVal] = useState("");  const JoinButton = ({ value, onPress }) => {    return (      <TouchableOpacity        style={{          backgroundColor: "#1178F8",          padding: 12,          marginVertical: 8,          borderRadius: 6,        }}        onPress={onPress}      >        <Text style={{ color: "white", alignSelf: "center", fontSize: 18 }}>          {value}        </Text>      </TouchableOpacity>    );  };  return (    <SafeAreaView      style={{        flex: 1,        backgroundColor: "black",        justifyContent: "center",        paddingHorizontal: 6 * 10,      }}    >      <TextInput        value={meetingVal}        onChangeText={setMeetingVal}        placeholder={"XXXX-XXXX-XXXX"}        placeholderTextColor={"grey"}        style={{          padding: 12,          borderWidth: 1,          borderColor: "white",          borderRadius: 6,          color: "white",          marginBottom: 16,        }}      />      <JoinButton        onPress={() => {          getMeetingAndToken(meetingVal);        }}        value={"Join as Host"}      />      <JoinButton        onPress={() => {          setMode("SIGNALLING_ONLY");          getMeetingAndToken(meetingVal);        }}        value={"Join as Viewer"}      />      <Text        style={{          alignSelf: "center",          fontSize: 22,          marginVertical: 16,          fontStyle: "italic",          color: "grey",        }}      >        ---------- OR ----------      </Text>      <JoinButton        onPress={() => {          getMeetingAndToken();        }}        value={"Create Studio Room"}      />    </SafeAreaView>  );}Output​

This functionality will have 3 buttons:1. Join as Host: When this button is clicked, the person will join the meeting with the entered meetingId as HOST.2. Join as Viewer: When this button is clicked, the person will join the meeting with the entered meetingId as SIGNALLING_ONLY.3. Create Studio Room: When this button is clicked, the person will join a new meeting as HOST.JoinScreen Componentfunction JoinScreen({ getMeetingAndToken, setMode }) {  const [meetingVal, setMeetingVal] = useState("");  const JoinButton = ({ value, onPress }) => {    return (      <TouchableOpacity        style={{          backgroundColor: "#1178F8",          padding: 12,          marginVertical: 8,          borderRadius: 6,        }}        onPress={onPress}      >        <Text style={{ color: "white", alignSelf: "center", fontSize: 18 }}>          {value}        </Text>      </TouchableOpacity>    );  };  return (    <SafeAreaView      style={{        flex: 1,        backgroundColor: "black",        justifyContent: "center",        paddingHorizontal: 6 * 10,      }}    >      <TextInput        value={meetingVal}        onChangeText={setMeetingVal}        placeholder={"XXXX-XXXX-XXXX"}        placeholderTextColor={"grey"}        style={{          padding: 12,          borderWidth: 1,          borderColor: "white",          borderRadius: 6,          color: "white",          marginBottom: 16,        }}      />      <JoinButton        onPress={() => {          getMeetingAndToken(meetingVal);        }}        value={"Join as Host"}      />      <JoinButton        onPress={() => {          setMode("SIGNALLING_ONLY");          getMeetingAndToken(meetingVal);        }}        value={"Join as Viewer"}      />      <Text        style={{          alignSelf: "center",          fontSize: 22,          marginVertical: 16,          fontStyle: "italic",          color: "grey",        }}      >        ---------- OR ----------      </Text>      <JoinButton        onPress={() => {          getMeetingAndToken();        }}        value={"Create Studio Room"}      />    </SafeAreaView>  );}Output​

1. Join as Host: When this button is clicked, the person will join the meeting with the entered meetingId as HOST.2. Join as Viewer: When this button is clicked, the person will join the meeting with the entered meetingId as SIGNALLING_ONLY.3. Create Studio Room: When this button is clicked, the person will join a new meeting as HOST.JoinScreen Componentfunction JoinScreen({ getMeetingAndToken, setMode }) {  const [meetingVal, setMeetingVal] = useState("");  const JoinButton = ({ value, onPress }) => {    return (      <TouchableOpacity        style={{          backgroundColor: "#1178F8",          padding: 12,          marginVertical: 8,          borderRadius: 6,        }}        onPress={onPress}      >        <Text style={{ color: "white", alignSelf: "center", fontSize: 18 }}>          {value}        </Text>      </TouchableOpacity>    );  };  return (    <SafeAreaView      style={{        flex: 1,        backgroundColor: "black",        justifyContent: "center",        paddingHorizontal: 6 * 10,      }}    >      <TextInput        value={meetingVal}        onChangeText={setMeetingVal}        placeholder={"XXXX-XXXX-XXXX"}        placeholderTextColor={"grey"}        style={{          padding: 12,          borderWidth: 1,          borderColor: "white",          borderRadius: 6,          color: "white",          marginBottom: 16,        }}      />      <JoinButton        onPress={() => {          getMeetingAndToken(meetingVal);        }}        value={"Join as Host"}      />      <JoinButton        onPress={() => {          setMode("SIGNALLING_ONLY");          getMeetingAndToken(meetingVal);        }}        value={"Join as Viewer"}      />      <Text        style={{          alignSelf: "center",          fontSize: 22,          marginVertical: 16,          fontStyle: "italic",          color: "grey",        }}      >        ---------- OR ----------      </Text>      <JoinButton        onPress={() => {          getMeetingAndToken();        }}        value={"Create Studio Room"}      />    </SafeAreaView>  );}Output​

`1. Join as Host:`
`meetingId`
`HOST`
2. Join as Viewer: When this button is clicked, the person will join the meeting with the entered meetingId as SIGNALLING_ONLY.3. Create Studio Room: When this button is clicked, the person will join a new meeting as HOST.JoinScreen Componentfunction JoinScreen({ getMeetingAndToken, setMode }) {  const [meetingVal, setMeetingVal] = useState("");  const JoinButton = ({ value, onPress }) => {    return (      <TouchableOpacity        style={{          backgroundColor: "#1178F8",          padding: 12,          marginVertical: 8,          borderRadius: 6,        }}        onPress={onPress}      >        <Text style={{ color: "white", alignSelf: "center", fontSize: 18 }}>          {value}        </Text>      </TouchableOpacity>    );  };  return (    <SafeAreaView      style={{        flex: 1,        backgroundColor: "black",        justifyContent: "center",        paddingHorizontal: 6 * 10,      }}    >      <TextInput        value={meetingVal}        onChangeText={setMeetingVal}        placeholder={"XXXX-XXXX-XXXX"}        placeholderTextColor={"grey"}        style={{          padding: 12,          borderWidth: 1,          borderColor: "white",          borderRadius: 6,          color: "white",          marginBottom: 16,        }}      />      <JoinButton        onPress={() => {          getMeetingAndToken(meetingVal);        }}        value={"Join as Host"}      />      <JoinButton        onPress={() => {          setMode("SIGNALLING_ONLY");          getMeetingAndToken(meetingVal);        }}        value={"Join as Viewer"}      />      <Text        style={{          alignSelf: "center",          fontSize: 22,          marginVertical: 16,          fontStyle: "italic",          color: "grey",        }}      >        ---------- OR ----------      </Text>      <JoinButton        onPress={() => {          getMeetingAndToken();        }}        value={"Create Studio Room"}      />    </SafeAreaView>  );}Output​

`2. Join as Viewer:`
`meetingId`
`SIGNALLING_ONLY`
3. Create Studio Room: When this button is clicked, the person will join a new meeting as HOST.JoinScreen Componentfunction JoinScreen({ getMeetingAndToken, setMode }) {  const [meetingVal, setMeetingVal] = useState("");  const JoinButton = ({ value, onPress }) => {    return (      <TouchableOpacity        style={{          backgroundColor: "#1178F8",          padding: 12,          marginVertical: 8,          borderRadius: 6,        }}        onPress={onPress}      >        <Text style={{ color: "white", alignSelf: "center", fontSize: 18 }}>          {value}        </Text>      </TouchableOpacity>    );  };  return (    <SafeAreaView      style={{        flex: 1,        backgroundColor: "black",        justifyContent: "center",        paddingHorizontal: 6 * 10,      }}    >      <TextInput        value={meetingVal}        onChangeText={setMeetingVal}        placeholder={"XXXX-XXXX-XXXX"}        placeholderTextColor={"grey"}        style={{          padding: 12,          borderWidth: 1,          borderColor: "white",          borderRadius: 6,          color: "white",          marginBottom: 16,        }}      />      <JoinButton        onPress={() => {          getMeetingAndToken(meetingVal);        }}        value={"Join as Host"}      />      <JoinButton        onPress={() => {          setMode("SIGNALLING_ONLY");          getMeetingAndToken(meetingVal);        }}        value={"Join as Viewer"}      />      <Text        style={{          alignSelf: "center",          fontSize: 22,          marginVertical: 16,          fontStyle: "italic",          color: "grey",        }}      >        ---------- OR ----------      </Text>      <JoinButton        onPress={() => {          getMeetingAndToken();        }}        value={"Create Studio Room"}      />    </SafeAreaView>  );}Output​

`3. Create Studio Room:`
`HOST`
```
function JoinScreen({ getMeetingAndToken, setMode }) {  const [meetingVal, setMeetingVal] = useState("");  const JoinButton = ({ value, onPress }) => {    return (      <TouchableOpacity        style={{          backgroundColor: "#1178F8",          padding: 12,          marginVertical: 8,          borderRadius: 6,        }}        onPress={onPress}      >        <Text style={{ color: "white", alignSelf: "center", fontSize: 18 }}>          {value}        </Text>      </TouchableOpacity>    );  };  return (    <SafeAreaView      style={{        flex: 1,        backgroundColor: "black",        justifyContent: "center",        paddingHorizontal: 6 * 10,      }}    >      <TextInput        value={meetingVal}        onChangeText={setMeetingVal}        placeholder={"XXXX-XXXX-XXXX"}        placeholderTextColor={"grey"}        style={{          padding: 12,          borderWidth: 1,          borderColor: "white",          borderRadius: 6,          color: "white",          marginBottom: 16,        }}      />      <JoinButton        onPress={() => {          getMeetingAndToken(meetingVal);        }}        value={"Join as Host"}      />      <JoinButton        onPress={() => {          setMode("SIGNALLING_ONLY");          getMeetingAndToken(meetingVal);        }}        value={"Join as Viewer"}      />      <Text        style={{          alignSelf: "center",          fontSize: 22,          marginVertical: 16,          fontStyle: "italic",          color: "grey",        }}      >        ---------- OR ----------      </Text>      <JoinButton        onPress={() => {          getMeetingAndToken();        }}        value={"Create Studio Room"}      />    </SafeAreaView>  );}
```

`function JoinScreen({ getMeetingAndToken, setMode }) {  const [meetingVal, setMeetingVal] = useState("");  const JoinButton = ({ value, onPress }) => {    return (      <TouchableOpacity        style={{          backgroundColor: "#1178F8",          padding: 12,          marginVertical: 8,          borderRadius: 6,        }}        onPress={onPress}      >        <Text style={{ color: "white", alignSelf: "center", fontSize: 18 }}>          {value}        </Text>      </TouchableOpacity>    );  };  return (    <SafeAreaView      style={{        flex: 1,        backgroundColor: "black",        justifyContent: "center",        paddingHorizontal: 6 * 10,      }}    >      <TextInput        value={meetingVal}        onChangeText={setMeetingVal}        placeholder={"XXXX-XXXX-XXXX"}        placeholderTextColor={"grey"}        style={{          padding: 12,          borderWidth: 1,          borderColor: "white",          borderRadius: 6,          color: "white",          marginBottom: 16,        }}      />      <JoinButton        onPress={() => {          getMeetingAndToken(meetingVal);        }}        value={"Join as Host"}      />      <JoinButton        onPress={() => {          setMode("SIGNALLING_ONLY");          getMeetingAndToken(meetingVal);        }}        value={"Join as Viewer"}      />      <Text        style={{          alignSelf: "center",          fontSize: 22,          marginVertical: 16,          fontStyle: "italic",          color: "grey",        }}      >        ---------- OR ----------      </Text>      <JoinButton        onPress={() => {          getMeetingAndToken();        }}        value={"Create Studio Room"}      />    </SafeAreaView>  );}`
#### Output​

### Step 4: Implement Container Component​

Next step is to create a container to manage Join screen, SpeakerView and ViewerView components based on the mode.You need to determine the mode of the localParticipant, if its SEND_AND_RECV, display the SpeakerView component otherwise show the ViewerView component.Container Componentfunction Container() {  const { join, changeWebcam, localParticipant } = useMeeting({    onError: (error) => {      console.log(error.message);    },  });  return (    <View style={{ flex: 1 }}>      {localParticipant?.mode == Constants.modes.SEND_AND_RECV ? (        <SpeakerView />      ) : localParticipant?.mode == Constants.modes.SIGNALLING_ONLY ? (        <ViewerView />      ) : (        <View          style={{            flex: 1,            justifyContent: "center",            alignItems: "center",            backgroundColor: "black",          }}        >          <Text style={{ fontSize: 20, color: "white" }}>            Press Join button to enter studio.          </Text>          <Button            btnStyle={{              marginTop: 8,              paddingHorizontal: 22,              padding: 12,              borderWidth: 1,              borderColor: "white",              borderRadius: 8,            }}            buttonText={"Join"}            onPress={() => {              join();            }}          />        </View>      )}    </View>  );}// Common Component which will also be used in Controls Componentconst Button = ({ onPress, buttonText, backgroundColor, btnStyle }) => {  return (    <TouchableOpacity      onPress={onPress}      style={{        ...btnStyle,        backgroundColor: backgroundColor,        padding: 10,        borderRadius: 8,      }}    >      <Text style={{ color: "white", fontSize: 12 }}>{buttonText}</Text>    </TouchableOpacity>  );};Output​

`Join screen`
`SpeakerView`
`ViewerView`
`mode`
You need to determine the mode of the localParticipant, if its SEND_AND_RECV, display the SpeakerView component otherwise show the ViewerView component.Container Componentfunction Container() {  const { join, changeWebcam, localParticipant } = useMeeting({    onError: (error) => {      console.log(error.message);    },  });  return (    <View style={{ flex: 1 }}>      {localParticipant?.mode == Constants.modes.SEND_AND_RECV ? (        <SpeakerView />      ) : localParticipant?.mode == Constants.modes.SIGNALLING_ONLY ? (        <ViewerView />      ) : (        <View          style={{            flex: 1,            justifyContent: "center",            alignItems: "center",            backgroundColor: "black",          }}        >          <Text style={{ fontSize: 20, color: "white" }}>            Press Join button to enter studio.          </Text>          <Button            btnStyle={{              marginTop: 8,              paddingHorizontal: 22,              padding: 12,              borderWidth: 1,              borderColor: "white",              borderRadius: 8,            }}            buttonText={"Join"}            onPress={() => {              join();            }}          />        </View>      )}    </View>  );}// Common Component which will also be used in Controls Componentconst Button = ({ onPress, buttonText, backgroundColor, btnStyle }) => {  return (    <TouchableOpacity      onPress={onPress}      style={{        ...btnStyle,        backgroundColor: backgroundColor,        padding: 10,        borderRadius: 8,      }}    >      <Text style={{ color: "white", fontSize: 12 }}>{buttonText}</Text>    </TouchableOpacity>  );};Output​

`localParticipant`
`SEND_AND_RECV`
`SpeakerView`
`ViewerView`
```
function Container() {  const { join, changeWebcam, localParticipant } = useMeeting({    onError: (error) => {      console.log(error.message);    },  });  return (    <View style={{ flex: 1 }}>      {localParticipant?.mode == Constants.modes.SEND_AND_RECV ? (        <SpeakerView />      ) : localParticipant?.mode == Constants.modes.SIGNALLING_ONLY ? (        <ViewerView />      ) : (        <View          style={{            flex: 1,            justifyContent: "center",            alignItems: "center",            backgroundColor: "black",          }}        >          <Text style={{ fontSize: 20, color: "white" }}>            Press Join button to enter studio.          </Text>          <Button            btnStyle={{              marginTop: 8,              paddingHorizontal: 22,              padding: 12,              borderWidth: 1,              borderColor: "white",              borderRadius: 8,            }}            buttonText={"Join"}            onPress={() => {              join();            }}          />        </View>      )}    </View>  );}// Common Component which will also be used in Controls Componentconst Button = ({ onPress, buttonText, backgroundColor, btnStyle }) => {  return (    <TouchableOpacity      onPress={onPress}      style={{        ...btnStyle,        backgroundColor: backgroundColor,        padding: 10,        borderRadius: 8,      }}    >      <Text style={{ color: "white", fontSize: 12 }}>{buttonText}</Text>    </TouchableOpacity>  );};
```

`function Container() {  const { join, changeWebcam, localParticipant } = useMeeting({    onError: (error) => {      console.log(error.message);    },  });  return (    <View style={{ flex: 1 }}>      {localParticipant?.mode == Constants.modes.SEND_AND_RECV ? (        <SpeakerView />      ) : localParticipant?.mode == Constants.modes.SIGNALLING_ONLY ? (        <ViewerView />      ) : (        <View          style={{            flex: 1,            justifyContent: "center",            alignItems: "center",            backgroundColor: "black",          }}        >          <Text style={{ fontSize: 20, color: "white" }}>            Press Join button to enter studio.          </Text>          <Button            btnStyle={{              marginTop: 8,              paddingHorizontal: 22,              padding: 12,              borderWidth: 1,              borderColor: "white",              borderRadius: 8,            }}            buttonText={"Join"}            onPress={() => {              join();            }}          />        </View>      )}    </View>  );}// Common Component which will also be used in Controls Componentconst Button = ({ onPress, buttonText, backgroundColor, btnStyle }) => {  return (    <TouchableOpacity      onPress={onPress}      style={{        ...btnStyle,        backgroundColor: backgroundColor,        padding: 10,        borderRadius: 8,      }}    >      <Text style={{ color: "white", fontSize: 12 }}>{buttonText}</Text>    </TouchableOpacity>  );};`
#### Output​

### Step 5: Implement SpeakerView​

Next step is to create SpeakerView and Controls components to manage features such as join, leave, mute and unmute.
You have to retrieve all the participants using the useMeeting hook and filter them based on the mode set to SEND_AND_RECV ensuring that only Speakers are displayed on the screen.
SpeakerViewfunction SpeakerView() {  // Get the Participant Map and meetingId  const { meetingId, participants } = useMeeting({});  // For getting speaker participant, filter out `SEND_AND_RECV` mode participant  const speakers = useMemo(() => {    const speakerParticipants = [...participants.values()].filter(      (participant) => {        return participant.mode == Constants.modes.SEND_AND_RECV;      }    );    return speakerParticipants;  }, [participants]);  return (    <SafeAreaView style={{ backgroundColor: "black", flex: 1 }}>      {/* Render Header for copy meetingId and leave meeting*/}      <HeaderView />      {/* Render Participant List */}      {speakers.length > 0 ? (        <FlatList          data={speakers}          renderItem={({ item }) => {            return <ParticipantView participantId={item.id} />;          }}        />      ) : null}      {/* Render Controls */}      <Controls />    </SafeAreaView>  );}function HeaderView() {  const { meetingId, leave } = useMeeting();  return (    <View      style={{        flexDirection: "row",        padding: 16,        justifyContent: "space-evenly",        alignItems: "center",      }}    >      <Text style={{ fontSize: 24, color: "white" }}>{meetingId}</Text>      <Button        btnStyle={{          borderWidth: 1,          borderColor: "white",        }}        onPress={() => {          Clipboard.setString(meetingId);          alert("MeetingId copied successfully");        }}        buttonText={"Copy MeetingId"}        backgroundColor={"transparent"}      />      <Button        onPress={() => {          leave();        }}        buttonText={"Leave"}        backgroundColor={"#FF0000"}      />    </View>  );}function Container(){  ...  const mMeeting = useMeeting({    onMeetingJoined: () => {      // Pin the local participant if he joins in SEND_AND_RECV mode      if (mMeetingRef.current.localParticipant.mode == "SEND_AND_RECV") {        mMeetingRef.current.localParticipant.pin();      }    }  });  // Create a ref to meeting object so that when used inside the  // Callback functions, meeting state is maintained  const mMeetingRef = useRef(mMeeting);  useEffect(() => {    mMeetingRef.current = mMeeting;  }, [mMeeting]);  return <>...</>;}
You need to then create the ParticipantView to display the participant's media. To play the media, use the webcamStream and micStream from the useParticipant hook.
ParticipantViewfunction ParticipantView({ participantId }) {  const { webcamStream, webcamOn } = useParticipant(participantId);  return webcamOn && webcamStream ? (    <RTCView      streamURL={new MediaStream([webcamStream.track]).toURL()}      objectFit={"cover"}      style={{        height: 300,        marginVertical: 8,        marginHorizontal: 8,      }}    />  ) : (    <View      style={{        backgroundColor: "grey",        height: 300,        justifyContent: "center",        alignItems: "center",        marginVertical: 8,        marginHorizontal: 8,      }}    >      <Text style={{ fontSize: 16 }}>NO MEDIA</Text>    </View>  );}
You have to add the Controls component which will allow the speaker to toggle their media and start/stop HLS.
Controls Componentfunction Controls() {  const { toggleWebcam, toggleMic, startHls, stopHls, hlsState } = useMeeting(    {}  );  const _handleHLS = async () => {    if (!hlsState || hlsState === "HLS_STOPPED") {      startHls({        layout: {          type: "SPOTLIGHT",          priority: "PIN",          gridSize: 4,        },        theme: "DARK",        orientation: "portrait",      });    } else if (hlsState === "HLS_STARTED" || hlsState === "HLS_PLAYABLE") {      stopHls();    }  };  return (    <View      style={{        padding: 24,        flexDirection: "row",        justifyContent: "space-between",      }}    >      <Button        onPress={() => {          toggleWebcam();        }}        buttonText={"Toggle Webcam"}        backgroundColor={"#1178F8"}      />      <Button        onPress={() => {          toggleMic();        }}        buttonText={"Toggle Mic"}        backgroundColor={"#1178F8"}      />      {hlsState === "HLS_STARTED" ||      hlsState === "HLS_STOPPING" ||      hlsState === "HLS_STARTING" ||      hlsState === "HLS_PLAYABLE" ? (        <Button          onPress={() => {            _handleHLS();          }}          buttonText={            hlsState === "HLS_STARTED"              ? `Live Starting`              : hlsState === "HLS_STOPPING"              ? `Live Stopping`              : hlsState === "HLS_PLAYABLE"              ? `Stop Live`              : `Loading...`          }          backgroundColor={"#FF5D5D"}        />      ) : (        <Button          onPress={() => {            _handleHLS();          }}          buttonText={`Go Live`}          backgroundColor={"#1178F8"}        />      )}    </View>  );}Output Of SpeakerView Component​

`SpeakerView`
`Controls`
1. You have to retrieve all the participants using the useMeeting hook and filter them based on the mode set to SEND_AND_RECV ensuring that only Speakers are displayed on the screen.

`participants`
`useMeeting`
`SEND_AND_RECV`
```
function SpeakerView() {  // Get the Participant Map and meetingId  const { meetingId, participants } = useMeeting({});  // For getting speaker participant, filter out `SEND_AND_RECV` mode participant  const speakers = useMemo(() => {    const speakerParticipants = [...participants.values()].filter(      (participant) => {        return participant.mode == Constants.modes.SEND_AND_RECV;      }    );    return speakerParticipants;  }, [participants]);  return (    <SafeAreaView style={{ backgroundColor: "black", flex: 1 }}>      {/* Render Header for copy meetingId and leave meeting*/}      <HeaderView />      {/* Render Participant List */}      {speakers.length > 0 ? (        <FlatList          data={speakers}          renderItem={({ item }) => {            return <ParticipantView participantId={item.id} />;          }}        />      ) : null}      {/* Render Controls */}      <Controls />    </SafeAreaView>  );}function HeaderView() {  const { meetingId, leave } = useMeeting();  return (    <View      style={{        flexDirection: "row",        padding: 16,        justifyContent: "space-evenly",        alignItems: "center",      }}    >      <Text style={{ fontSize: 24, color: "white" }}>{meetingId}</Text>      <Button        btnStyle={{          borderWidth: 1,          borderColor: "white",        }}        onPress={() => {          Clipboard.setString(meetingId);          alert("MeetingId copied successfully");        }}        buttonText={"Copy MeetingId"}        backgroundColor={"transparent"}      />      <Button        onPress={() => {          leave();        }}        buttonText={"Leave"}        backgroundColor={"#FF0000"}      />    </View>  );}function Container(){  ...  const mMeeting = useMeeting({    onMeetingJoined: () => {      // Pin the local participant if he joins in SEND_AND_RECV mode      if (mMeetingRef.current.localParticipant.mode == "SEND_AND_RECV") {        mMeetingRef.current.localParticipant.pin();      }    }  });  // Create a ref to meeting object so that when used inside the  // Callback functions, meeting state is maintained  const mMeetingRef = useRef(mMeeting);  useEffect(() => {    mMeetingRef.current = mMeeting;  }, [mMeeting]);  return <>...</>;}
```

`function SpeakerView() {  // Get the Participant Map and meetingId  const { meetingId, participants } = useMeeting({});  // For getting speaker participant, filter out `SEND_AND_RECV` mode participant  const speakers = useMemo(() => {    const speakerParticipants = [...participants.values()].filter(      (participant) => {        return participant.mode == Constants.modes.SEND_AND_RECV;      }    );    return speakerParticipants;  }, [participants]);  return (    <SafeAreaView style={{ backgroundColor: "black", flex: 1 }}>      {/* Render Header for copy meetingId and leave meeting*/}      <HeaderView />      {/* Render Participant List */}      {speakers.length > 0 ? (        <FlatList          data={speakers}          renderItem={({ item }) => {            return <ParticipantView participantId={item.id} />;          }}        />      ) : null}      {/* Render Controls */}      <Controls />    </SafeAreaView>  );}function HeaderView() {  const { meetingId, leave } = useMeeting();  return (    <View      style={{        flexDirection: "row",        padding: 16,        justifyContent: "space-evenly",        alignItems: "center",      }}    >      <Text style={{ fontSize: 24, color: "white" }}>{meetingId}</Text>      <Button        btnStyle={{          borderWidth: 1,          borderColor: "white",        }}        onPress={() => {          Clipboard.setString(meetingId);          alert("MeetingId copied successfully");        }}        buttonText={"Copy MeetingId"}        backgroundColor={"transparent"}      />      <Button        onPress={() => {          leave();        }}        buttonText={"Leave"}        backgroundColor={"#FF0000"}      />    </View>  );}function Container(){  ...  const mMeeting = useMeeting({    onMeetingJoined: () => {      // Pin the local participant if he joins in SEND_AND_RECV mode      if (mMeetingRef.current.localParticipant.mode == "SEND_AND_RECV") {        mMeetingRef.current.localParticipant.pin();      }    }  });  // Create a ref to meeting object so that when used inside the  // Callback functions, meeting state is maintained  const mMeetingRef = useRef(mMeeting);  useEffect(() => {    mMeetingRef.current = mMeeting;  }, [mMeeting]);  return <>...</>;}`
1. You need to then create the ParticipantView to display the participant's media. To play the media, use the webcamStream and micStream from the useParticipant hook.

`ParticipantView`
`webcamStream`
`micStream`
`useParticipant`
```
function ParticipantView({ participantId }) {  const { webcamStream, webcamOn } = useParticipant(participantId);  return webcamOn && webcamStream ? (    <RTCView      streamURL={new MediaStream([webcamStream.track]).toURL()}      objectFit={"cover"}      style={{        height: 300,        marginVertical: 8,        marginHorizontal: 8,      }}    />  ) : (    <View      style={{        backgroundColor: "grey",        height: 300,        justifyContent: "center",        alignItems: "center",        marginVertical: 8,        marginHorizontal: 8,      }}    >      <Text style={{ fontSize: 16 }}>NO MEDIA</Text>    </View>  );}
```

`function ParticipantView({ participantId }) {  const { webcamStream, webcamOn } = useParticipant(participantId);  return webcamOn && webcamStream ? (    <RTCView      streamURL={new MediaStream([webcamStream.track]).toURL()}      objectFit={"cover"}      style={{        height: 300,        marginVertical: 8,        marginHorizontal: 8,      }}    />  ) : (    <View      style={{        backgroundColor: "grey",        height: 300,        justifyContent: "center",        alignItems: "center",        marginVertical: 8,        marginHorizontal: 8,      }}    >      <Text style={{ fontSize: 16 }}>NO MEDIA</Text>    </View>  );}`
1. You have to add the Controls component which will allow the speaker to toggle their media and start/stop HLS.

`Controls`
```
function Controls() {  const { toggleWebcam, toggleMic, startHls, stopHls, hlsState } = useMeeting(    {}  );  const _handleHLS = async () => {    if (!hlsState || hlsState === "HLS_STOPPED") {      startHls({        layout: {          type: "SPOTLIGHT",          priority: "PIN",          gridSize: 4,        },        theme: "DARK",        orientation: "portrait",      });    } else if (hlsState === "HLS_STARTED" || hlsState === "HLS_PLAYABLE") {      stopHls();    }  };  return (    <View      style={{        padding: 24,        flexDirection: "row",        justifyContent: "space-between",      }}    >      <Button        onPress={() => {          toggleWebcam();        }}        buttonText={"Toggle Webcam"}        backgroundColor={"#1178F8"}      />      <Button        onPress={() => {          toggleMic();        }}        buttonText={"Toggle Mic"}        backgroundColor={"#1178F8"}      />      {hlsState === "HLS_STARTED" ||      hlsState === "HLS_STOPPING" ||      hlsState === "HLS_STARTING" ||      hlsState === "HLS_PLAYABLE" ? (        <Button          onPress={() => {            _handleHLS();          }}          buttonText={            hlsState === "HLS_STARTED"              ? `Live Starting`              : hlsState === "HLS_STOPPING"              ? `Live Stopping`              : hlsState === "HLS_PLAYABLE"              ? `Stop Live`              : `Loading...`          }          backgroundColor={"#FF5D5D"}        />      ) : (        <Button          onPress={() => {            _handleHLS();          }}          buttonText={`Go Live`}          backgroundColor={"#1178F8"}        />      )}    </View>  );}
```

`function Controls() {  const { toggleWebcam, toggleMic, startHls, stopHls, hlsState } = useMeeting(    {}  );  const _handleHLS = async () => {    if (!hlsState || hlsState === "HLS_STOPPED") {      startHls({        layout: {          type: "SPOTLIGHT",          priority: "PIN",          gridSize: 4,        },        theme: "DARK",        orientation: "portrait",      });    } else if (hlsState === "HLS_STARTED" || hlsState === "HLS_PLAYABLE") {      stopHls();    }  };  return (    <View      style={{        padding: 24,        flexDirection: "row",        justifyContent: "space-between",      }}    >      <Button        onPress={() => {          toggleWebcam();        }}        buttonText={"Toggle Webcam"}        backgroundColor={"#1178F8"}      />      <Button        onPress={() => {          toggleMic();        }}        buttonText={"Toggle Mic"}        backgroundColor={"#1178F8"}      />      {hlsState === "HLS_STARTED" ||      hlsState === "HLS_STOPPING" ||      hlsState === "HLS_STARTING" ||      hlsState === "HLS_PLAYABLE" ? (        <Button          onPress={() => {            _handleHLS();          }}          buttonText={            hlsState === "HLS_STARTED"              ? `Live Starting`              : hlsState === "HLS_STOPPING"              ? `Live Stopping`              : hlsState === "HLS_PLAYABLE"              ? `Stop Live`              : `Loading...`          }          backgroundColor={"#FF5D5D"}        />      ) : (        <Button          onPress={() => {            _handleHLS();          }}          buttonText={`Go Live`}          backgroundColor={"#1178F8"}        />      )}    </View>  );}`
#### Output Of SpeakerView Component​

`SpeakerView`
### Step 6: Implement ViewerView​

When the HOST (SEND_AND_RECV mode participant) initiates the live streaming, viewers will be able to watch it.To implement the player view, you have to use react-native-video. It will be helpful for playing the HLS stream.Begin by adding this package.NPMYarnnpm install react-native-videoyarn add react-native-videoWith react-native-video installed, you can now get the hlsUrls and isHlsPlayable from the useMeeting hook which will be used to play the HLS in the player.// imports react-native-videoimport Video from "react-native-video";function ViewerView({}) {  const { hlsState, hlsUrls } = useMeeting();  return (    <SafeAreaView style={{ flex: 1, backgroundColor: "black" }}>      {hlsState == "HLS_PLAYABLE" ? (        <>          {/* Render Header for copying the meetingId and leaving meeting*/}          <HeaderView />          {/* Render VideoPlayer that will play `downstreamUrl`*/}          <Video            controls={true}            source={{              uri: hlsUrls.downstreamUrl,            }}            resizeMode={"stretch"}            style={{              flex: 1,              backgroundColor: "black",            }}            onError={(e) => console.log("error", e)}          />        </>      ) : (        <SafeAreaView          style={{ flex: 1, justifyContent: "center", alignItems: "center" }}        >          <Text style={{ fontSize: 20, color: "white" }}>            HLS is not started yet or is stopped          </Text>        </SafeAreaView>      )}    </SafeAreaView>  );}Output of ViewerView Component​

`SEND_AND_RECV`
To implement the player view, you have to use react-native-video. It will be helpful for playing the HLS stream.Begin by adding this package.NPMYarnnpm install react-native-videoyarn add react-native-videoWith react-native-video installed, you can now get the hlsUrls and isHlsPlayable from the useMeeting hook which will be used to play the HLS in the player.// imports react-native-videoimport Video from "react-native-video";function ViewerView({}) {  const { hlsState, hlsUrls } = useMeeting();  return (    <SafeAreaView style={{ flex: 1, backgroundColor: "black" }}>      {hlsState == "HLS_PLAYABLE" ? (        <>          {/* Render Header for copying the meetingId and leaving meeting*/}          <HeaderView />          {/* Render VideoPlayer that will play `downstreamUrl`*/}          <Video            controls={true}            source={{              uri: hlsUrls.downstreamUrl,            }}            resizeMode={"stretch"}            style={{              flex: 1,              backgroundColor: "black",            }}            onError={(e) => console.log("error", e)}          />        </>      ) : (        <SafeAreaView          style={{ flex: 1, justifyContent: "center", alignItems: "center" }}        >          <Text style={{ fontSize: 20, color: "white" }}>            HLS is not started yet or is stopped          </Text>        </SafeAreaView>      )}    </SafeAreaView>  );}Output of ViewerView Component​

Begin by adding this package.NPMYarnnpm install react-native-videoyarn add react-native-videoWith react-native-video installed, you can now get the hlsUrls and isHlsPlayable from the useMeeting hook which will be used to play the HLS in the player.// imports react-native-videoimport Video from "react-native-video";function ViewerView({}) {  const { hlsState, hlsUrls } = useMeeting();  return (    <SafeAreaView style={{ flex: 1, backgroundColor: "black" }}>      {hlsState == "HLS_PLAYABLE" ? (        <>          {/* Render Header for copying the meetingId and leaving meeting*/}          <HeaderView />          {/* Render VideoPlayer that will play `downstreamUrl`*/}          <Video            controls={true}            source={{              uri: hlsUrls.downstreamUrl,            }}            resizeMode={"stretch"}            style={{              flex: 1,              backgroundColor: "black",            }}            onError={(e) => console.log("error", e)}          />        </>      ) : (        <SafeAreaView          style={{ flex: 1, justifyContent: "center", alignItems: "center" }}        >          <Text style={{ fontSize: 20, color: "white" }}>            HLS is not started yet or is stopped          </Text>        </SafeAreaView>      )}    </SafeAreaView>  );}Output of ViewerView Component​

- NPMYarn

```
npm install react-native-video
```

`npm install react-native-video`
```
yarn add react-native-video
```

`yarn add react-native-video`
With react-native-video installed, you can now get the hlsUrls and isHlsPlayable from the useMeeting hook which will be used to play the HLS in the player.// imports react-native-videoimport Video from "react-native-video";function ViewerView({}) {  const { hlsState, hlsUrls } = useMeeting();  return (    <SafeAreaView style={{ flex: 1, backgroundColor: "black" }}>      {hlsState == "HLS_PLAYABLE" ? (        <>          {/* Render Header for copying the meetingId and leaving meeting*/}          <HeaderView />          {/* Render VideoPlayer that will play `downstreamUrl`*/}          <Video            controls={true}            source={{              uri: hlsUrls.downstreamUrl,            }}            resizeMode={"stretch"}            style={{              flex: 1,              backgroundColor: "black",            }}            onError={(e) => console.log("error", e)}          />        </>      ) : (        <SafeAreaView          style={{ flex: 1, justifyContent: "center", alignItems: "center" }}        >          <Text style={{ fontSize: 20, color: "white" }}>            HLS is not started yet or is stopped          </Text>        </SafeAreaView>      )}    </SafeAreaView>  );}Output of ViewerView Component​

`react-native-video`
`hlsUrls`
`isHlsPlayable`
`useMeeting`
```
// imports react-native-videoimport Video from "react-native-video";function ViewerView({}) {  const { hlsState, hlsUrls } = useMeeting();  return (    <SafeAreaView style={{ flex: 1, backgroundColor: "black" }}>      {hlsState == "HLS_PLAYABLE" ? (        <>          {/* Render Header for copying the meetingId and leaving meeting*/}          <HeaderView />          {/* Render VideoPlayer that will play `downstreamUrl`*/}          <Video            controls={true}            source={{              uri: hlsUrls.downstreamUrl,            }}            resizeMode={"stretch"}            style={{              flex: 1,              backgroundColor: "black",            }}            onError={(e) => console.log("error", e)}          />        </>      ) : (        <SafeAreaView          style={{ flex: 1, justifyContent: "center", alignItems: "center" }}        >          <Text style={{ fontSize: 20, color: "white" }}>            HLS is not started yet or is stopped          </Text>        </SafeAreaView>      )}    </SafeAreaView>  );}
```

`// imports react-native-videoimport Video from "react-native-video";function ViewerView({}) {  const { hlsState, hlsUrls } = useMeeting();  return (    <SafeAreaView style={{ flex: 1, backgroundColor: "black" }}>      {hlsState == "HLS_PLAYABLE" ? (        <>          {/* Render Header for copying the meetingId and leaving meeting*/}          <HeaderView />          {/* Render VideoPlayer that will play `downstreamUrl`*/}          <Video            controls={true}            source={{              uri: hlsUrls.downstreamUrl,            }}            resizeMode={"stretch"}            style={{              flex: 1,              backgroundColor: "black",            }}            onError={(e) => console.log("error", e)}          />        </>      ) : (        <SafeAreaView          style={{ flex: 1, justifyContent: "center", alignItems: "center" }}        >          <Text style={{ fontSize: 20, color: "white" }}>            HLS is not started yet or is stopped          </Text>        </SafeAreaView>      )}    </SafeAreaView>  );}`
#### Output of ViewerView Component​

`ViewerView`
Stuck anywhere? Check out this example code on GitHub

Got a Question? Ask us on discord

- PrerequisitesApp ArchitectureGetting Started with the Code!Create AppVideoSDK InstallationProject StructureProject ConfigurationAndroid SetupiOS SetupRegister ServiceStep 1: Get started with API.jsStep 2: Wireframe App.js with all the componentsStep 3: Implement Join ScreenOutputStep 4: Implement Container ComponentOutputStep 5: Implement SpeakerViewOutput Of SpeakerView ComponentStep 6: Implement ViewerViewOutput of ViewerView Component

- Create AppVideoSDK InstallationProject StructureProject ConfigurationAndroid SetupiOS SetupRegister ServiceStep 1: Get started with API.jsStep 2: Wireframe App.js with all the componentsStep 3: Implement Join ScreenOutputStep 4: Implement Container ComponentOutputStep 5: Implement SpeakerViewOutput Of SpeakerView ComponentStep 6: Implement ViewerViewOutput of ViewerView Component

- Android SetupiOS SetupRegister Service

- Output

- Output

- Output Of SpeakerView Component

`SpeakerView`
- Output of ViewerView Component

`ViewerView`
Was this helpful?
